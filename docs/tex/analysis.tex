\chapter{Аналитическая часть}

В данной части проводится анализ объектов сцены и существующих алгоритмов построения изображений и выбор более подходящих алгоритмов для дальнейшего использования.

\section{Описание объектов визуализируемой сцены}

Трехмерная сцена состоит из нескольких компонентов.
\begin{enumerate}
    \item Объекты сцены, представляющих из себя многогранники, расположенные в пространстве сцены. 
    Каждый многогранник задается списком полигонов, где полигон описывается множеством точек в трехмерном пространстве.
    \item Материалы и свойства объектов сцены. 
    Каждый объект может иметь определенные свойства, включая цвет, текстуры, прозрачность, отражение и блеск. 
    Эти свойства могут быть формализованы с помощью числовых параметров, которые определяют, как объект взаимодействует со светом и как он будет визуализирован. 
    \item Источники света, которые могут быть формализованы как направленные вектора.
    \item Камера, через которую наблюдается данная сцена. 
    Ее параметры могут включать положение, ориентацию, угол обзора и другие характеристики.
\end{enumerate}

\section{Анализ алгоритмов удаления невидимых линий и поверхностей}

В процессе создания реалистичных изображений ключевой задачей является обеспечение видимости объектов и их частей, учитывая перекрытия между ними. Другими словами, необходимо определить, какие элементы сцены должны быть видны, а какие скрыты от наблюдателя. Эта задача решается с помощью двух групп алгоритмов~\cite{rogers}.
\begin{enumerate}
    \item Алгоритмы, оперирующие в объектном пространстве. 
    Эти алгоритмы связаны с мировой или физической системой координат. 
    Они предназначены для определения видимости объектов, учитывая их пространственное расположение. 
    Однако такие методы требуют значительных вычислительных ресурсов, которые зависят от сложности сцены и необходимой точности. 
    Примерами таких алгоритмов могут быть алгоритм Робертса, алгоритмы на основе списков приоритетов и др.
    \item Алгоритмы, оперирующие в пространстве изображения. 
    Эти алгоритмы ориентированы на систему координат экрана или плоскости изображения, на которую проецируются объекты. 
    Этот подход требует меньше вычислительных ресурсов по сравнению с первой группой, и его объем зависит от разрешения экрана и количества объектов на сцене. 
    Примерами таких алгоритмов являются алгоритм Варнака, алгоритм Z-буфера и метод трассировки лучей.
\end{enumerate}

\subsection{Алгоритм Робертса}

Алгоритм Робертса — это метод удаления невидимых линий и поверхностей в компьютерной графике, который действует в объектном пространстве~\cite{rogers}. 
Его основной целью является определение, какие линии (рёбра) объектов на сцене будут видны из точки наблюдения, а какие будут скрыты за другими объектами.

Алгоритм Робертса делится на 3 этапа.
\begin{enumerate}
    \item На первом этапе каждое тело анализируется индивидуально с целью удаления нелицевых плоскостей. 
    Для каждого тела и каждой грани тела вычисляется уравнение плоскости. 
    После чего проверяется знак уравнения плоскости и формируется матрица тела. 
    \item Удаление из каждого тела тех ребер, которые экранируются всеми остальными телами в сцене. 
    Если задано только одно тело, то алгоритм завершается.
    \item На третьем этапе вычисляются отрезки, которые образуют новые ребра при протыкании телами друг друга. 
\end{enumerate}

За счет того, что алгоритм Робертса работает в объектном пространстве, получается достичь высокую точность результирующего изображения. 
Однако в данном алгоритме используется много трудоемких математических вычислений и сложность растет как квадрат числа объектов на сцене.

\subsection{Алгоритм, использующий Z-буфер}

Алгоритм, использующий Z-буфер, представляет собой один из наиболее простых и широко применяемых методов для удаления невидимых поверхностей. Этот алгоритм оперирует в пространстве изображения и основывается на идее использования двух буферов: буфера кадра и Z-буфера.

\begin{enumerate}
    \item Буфер кадра (англ. Frame Buffer). 
    Этот буфер представляет собой массив пикселей, в котором будут храниться атрибуты (например, цвет) каждого пикселя на экране.
    \item Z-буфер (англ. Depth Buffer). 
    Это отдельный буфер глубины, который будет хранить глубину (Z-координату) каждого пикселя на экране. 
    Исходно он заполняется максимально возможными значениями глубины.
\end{enumerate}

Алгоритм работает следующим образом.
\begin{enumerate}
    \item Перед началом работы буфер кадра заполняется информацией о фоновом изображении, а Z-буфер заполняется минимальными значениями глубины.
    \item Для каждого объекта на сцене: 
    \begin{itemize}
        \item полигоны объекта преобразуются в растровую форму;
        \item для каждого пикселя текущего полигона проверяется его Z-координата (глубина) в сравнении с соответствующим значением в Z-буфере;
        \item если Z-координата текущего пикселя меньше, чем значение в Z-буфере, то пиксель заносится в буфер кадра, а его Z-координата обновляется в Z-буфере.
    \end{itemize}
    \item На выходе получается изображение, в котором каждый пиксель находится в буфере кадра в соответствии с его видимостью и глубиной.
\end{enumerate}

К преимуществам относятся простота реализации, которая позволяет достичь хороших результатов без сложной сортировки объектов. Также алгоритм эффективно обрабатывает сцены с большим количеством объектов.

К недостаткам можно отнести потребление большого объема памяти для хранения двух буферов, а также могут быть проблемы с прозрачностью и лестничным эффектом (ступенчатость на границах объектов).

\subsection{Алгоритм Варнока}

Алгоритм Варнока -- это метод удаления невидимых поверхностей в компьютерной графике, который использует разбиение сцены на более мелкие части для определения видимости объектов. 
Алгоритм работает в пространстве изображения и анализирует область на экране дисплея (окно) на наличие в них видимых элементов~\cite{delinvis}. 

Идея алгоритма Варнока заключается в разбиении экрана на рекурсивные прямоугольники, которые обозначают различные части сцены. 
Затем каждый прямоугольник проверяется на наличие видимых объектов. 
Если внутри прямоугольника объекты видимы, он разбивается на более мелкие прямоугольники, и процесс продолжается до достижения требуемого уровня детализации или пока не будут найдены видимые объекты.

Процесс алгоритма Варнока.
\begin{enumerate}
    \item Разбиение экрана. 
    Исходный экран разбивается на начальные прямоугольники. 
    Эти прямоугольники могут представлять собой целый экран или другие крупные области.
    \item Проверка видимости. 
    Для каждого прямоугольника выполняется проверка видимости объектов, находящихся внутри него. 
    \includeimage
        {relationship}
        {f}
        {h}
        {0.8\textwidth}
        {Варианты взаимного расположения многоугольников~\cite{delinvis}}
    \item Принятие решения. 
    В зависимости от результата проверки видимости объектов внутри прямоугольника, он может быть разбит на более мелкие подпрямоугольники или объединен с другими прямоугольниками. 
    Этот процесс продолжается рекурсивно.
    \item Заполнение буфера кадра. 
    Для видимых прямоугольников или их частей выполняется заполнение буфера кадра атрибутами объектов.
    \item Завершение. 
    Процесс рекурсивного разбиения и проверки видимости продолжается до достижения требуемого уровня детализации или до тех пор, пока не будет достигнута наименьшая обрабатываемая единица.
\end{enumerate}

Преимущества алгоритма Варнока включают возможность обработки сложных сцен, включая объекты с перекрывающимися поверхностями. 
Однако он может потребовать больших вычислительных ресурсов и времени, особенно при работе с детализированными сценами. 

\subsection{Алгоритм, использующий список приоритетов}

Этот алгоритм базируется на упорядочивании объектов сцены в зависимости от их приоритета, который определяется их удаленностью от наблюдателя или глубиной в сцене. 
Идея заключается в начальном рендеринге объектов, находящихся на большем расстоянии от наблюдателя, и последующем перекрытии их ближайшими объектами.

Сначала происходит сортировка объектов по глубине, что создает первоначальный список приоритетов. 
Затем этот список подвергается коррекции через выполнение тестов на экранирование для каждой пары многоугольников в списке. 
Эти тесты могут быть достаточно затратными по времени и сложности реализации. 
Суть тестов заключается в определении, перекрывает ли один многоугольник другой, и, если да, то какой из них ближе к наблюдателю.

Важно отметить, что идентификация случаев пересечения и циклического перекрытия многоугольников в этом алгоритме является сложной задачей. 
Вследствие этого алгоритм может сталкиваться с ограничениями в эффективности и точности при обработке таких сцен, где объекты перекрывают друг друга в сложных сценариях.

\subsection{Алгоритм трассировки лучей}

Алгоритм трассировки лучей -- это метод удаления невидимых поверхностей в компьютерной графике, который симулирует путь световых лучей, падающих на объекты в сцене. 
Он создает фотореалистичные изображения, учитывая отражение, преломление и тени. 

Предполагается, что наблюдатель находится на бесконечности положительной полуоси Z, и все световые лучи от наблюдателя параллельны этой оси. 
В ходе алгоритма обратной трассировки лучей, начиная от наблюдателя, генерируются лучи и находятся пересечения этих лучей с объектами сцены. 
Путем анализа этих пересечений определяется самая ближняя точка пересечения по оси Z, которая представляет видимую часть поверхности. 
Атрибуты этого объекта затем используются для определения характеристик пикселя, через который проходит этот световой луч.

Для создания реалистичных эффектов освещения алгоритм генерирует дополнительные лучи от точек пересечения к источникам света. 
Если на пути такого луча встречается непрозрачный объект, это означает, что данная точка находится в тени.

\includeimage
    {ray_tracing}
    {f}
    {h}
    {1.0\textwidth}
    {Визуализация алгоритма трассировки лучей~\cite{tracing}}

Основными преимуществами данного алгоритма являются реалистичность получаемого изображения и возможность анализировать наложение света. 
Однако из-за использования большого количества лучей производительность алгоритм снижается, поскольку для каждого луча необходимо производить поиск пересечений с объектами сцены.

\section{Анализ алгоритмов закраски}

\subsection{Простая закраска}
Применяется закрашивание, в котором каждая грань получает один уровень интенсивности, вычисляемый согласно закону Ламберта. 
В результате такой закраски все плоские поверхности, включая те, что аппроксимируют фигуры, подвергаются однородному окрашиванию. 
В случае фигур вращения это может вызвать появление ложных границ между поверхностями.

Этот метод обладает высокой производительностью, однако все пиксели на грани получают одинаковую интенсивность, что придает сцене нереалистичный вид. 
Несмотря на это, метод очень прост в реализации и не требует значительных вычислительных ресурсов.

\subsection{Закраска по Гуро}

Закраска по методу Гуро основана на билинейной интерполяции интенсивностей на поверхности грани. 
Этот метод создает иллюзию плавной криволинейной поверхности, так как интенсивность вычисляется для каждой точки грани, что способствует мягкому переходу между цветами.

Закраска по методу Гуро хорошо сочетается с простой моделью освещения, основанной на диффузном отражении света. 
Она значительно улучшает качество изображения, придавая ему более реалистичный вид.

% Вопрос про ГОСТ, 2 элемента списка
Однако у этого метода есть свои недостатки:
\begin{itemize}
    \item возникает эффект полос Маха -- артефакт, проявляющийся в виде полос вдоль граней изображения;
    \item из-за сглаживания интенсивностей может быть утрачена четкая граница между гранями многогранника, что в некоторых ситуациях может привести к неверному визуальному результату.
\end{itemize}

Процедура закрашивания граней методом Гуро состоит из четырех последовательных этапов.
\begin{enumerate}
    \item Вычисление граничных нормалей. 
    На этом этапе определяются нормали для каждой отдельной грани. 
    Нормаль -- это вектор, перпендикулярный к поверхности грани и указывающий направление в пространстве.
    \item Определение вершинных нормалей. 
    Затем определяются нормали в вершинах объекта. 
    Нормаль в вершине вычисляется как среднее значение нормалей граней, смежных с данной вершиной. 
    Это позволяет создать плавные переходы между нормалями граней и учесть геометрическую структуру объекта.
    \item Вычисление яркостей в вершинах. 
    Исходя из нормалей в вершинах, определяются значения яркостей (интенсивностей) в этих вершинах, согласно выбранной модели отражения света. 
    Это позволяет учесть, как свет падает на разные части объекта.
    \item Закрашивание граней. 
    Наконец, происходит закрашивание полигонов граней. 
    Каждая грань получает цвет, который вычисляется путем линейной интерполяции значений интенсивностей в вершинах этой грани. 
    Это создает плавные переходы цветов на поверхности и добавляет визуальную реалистичность объекту.
\end{enumerate}

\subsection{Закраска по Фонгу}

Закраска по модели Фонга, по своей концепции, схожа с закраской по методу Гуро, но имеет отличие в том, как интерполируются значения. 
В методе Гуро производится интерполяция значений интенсивности для всех точек полигона, тогда как в методе Фонга интерполируются векторы нормалей граней, и на основе этих нормалей определяется интенсивность для каждой точки~\cite{phong}.

Этапы алгоритма закраски по Фонгу следующие.
\begin{enumerate}
    \item Вычисление нормалей для каждой грани.
    \item На основе нормалей граней определяются нормали в вершинах. 
    В каждой точке грани интерполируется вектор нормали, учитывая соседние вершины.
    \item С использованием направления векторов нормали определяется цвет точек грани в соответствии с выбранной моделью освещения.
\end{enumerate}

Алгоритм закраски по модели Фонга требует больше вычислительных ресурсов по сравнению с предыдущими методами, но он позволяет достичь лучшей локальной аппроксимации кривизны поверхности. 
Это приводит к более реалистичному изображению, так как метод учитывает изменения в направлениях нормалей на поверхности, что способствует созданию более точных эффектов освещения.

\section{Критерии выбора алгоритмов трехмерной визуализации}
При выборе алгоритмов компьютерной графики для визуализации трехмерной сцены следует учитывать особенности платформы, с помощью которой будет решаться задача. 
В данном случае необходимо рассмотреть возможности микроконтроллеров.

\begin{enumerate}
    \item Объем оперативной памяти на микроконтроллере достаточно ограничен. 
    Обычно он составляет не больше нескольких мегабайт. 
    Поэтому при выборе алгоритмов стоит учитывать размер используемых структур данных и затраченной памяти в целом.
    \item Вычислительная мощность микроконтроллеров также невысокая, поэтому при выборе алгоритма стоит учитывать его простоту и эффективность работы. 
    Немаловажной будет являться сложность работы алгоритма, по возможности, она должна быть линейной в зависимости от количества объектов сцены. 
    \item Объем встроенной постоянной памяти в микроконтроллерах небольшой и составляет не более 2 мегабайт. 
    Исходя из этого размер исполняемого файла должен быть меньше, поэтому стоит выбирать алгоритмы, реализация которых более лаконичная и компактная.
\end{enumerate}

Для поставленной задачи критерий, связанный с объемом оперативной памяти, будет приоритетным.

\section{Вывод из аналитической части}

Проанализировав алгоритмы удаления невидимых линий и поверхностей и различные алгоритмы закраски, а также рассмотрев критерии выбора наиболее оптимального алгоритма для поставленной задачи визуализации трехмерной сцены с использованием микроконтроллера, можно сделать вывод, что алгоритм Варнока и алгоритм простой закраски подходят лучше всего. 
Алгоритм Варнока использует оптимальное количество памяти и требует меньшей вычислительной мощности, по сравнению с другими алгоритмами. 
Простая закраска наименее ресурсоемкая из всех алгоритмов закраски, при этом позволяет достичь поставленной цели. При выборе алгоритмов ключевую роль играли особенности аппаратной платформы.
